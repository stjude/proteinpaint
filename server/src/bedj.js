import fs from 'fs'
import path from 'path'
import { createCanvas } from 'canvas'
import * as utils from './utils.js'
import { nt2aa } from '#shared/common.js'
import { parseBedLine } from './bedj.parseBed.js'

/*
should guard against file content error e.g. two tabs separating columns

*********************** req.query{}
.genome: str
	only required for gene tracks that will be translated, otherwise not required
.name: str
	not used
.file:
	tp file path
.rglst: []
	{chr, start, stop, width, reverse}
	start is 0-based
	stop is non-inclusive (e.g. start:019, stop:119 to show 100bp range)
	width: real number, #pixel width of this region
.gmregion:{ chr, start, stop, width, reverse }
	generated by tkarg_bedj
	if provided, rglst[] will be (subset of) exons of this gene model
	it will query bedj file with the gmregion, but not individual regions of rglst, to cut down computing


## item filtering

.usevalue:{ key, dropBelowCutoff }
	quick fix
	key is for accessing a numeric value of an item via item[usevalue.key]
	if the value < dropBelowCutoff, will skip the item
.filterByName: str
	provide isoform names joined by newline to only show those items
TODO filter by category
.bplengthUpperLimit: int
	max bp length of bed items; don't know where this is used!
.isoform: str
	provide an isoform name which should be the one used in the client side gmmode
	allow to filter bed items by .isoformonly attribute

## short cut to retrieve data without rendering

.getdata: true
	if true, will return bed data and do not render image
	rendering-related parameters will be ignored
.getBED: true
	may set when getdata=true.
	will return {chr,start,stop, rest[]} for all bed items, and do not render track image
	used for getting data from hic fragment file

## rendering parameters

.regionspace: int
	#pixel width between two regions
.width: real
	total width of all regions
.stackheight: int
	row height shared by all rows
.stackspace: int
	#pixel spacing between rows
.color:
	optional global color; can be overwritten by item.color
.translatecoding: true
	if true, will translate coding sequence based on item.coding[] when resolution is high enough
.__isgene: true
	if true, while rendering, will return gene model data when there're less than 50 in view range
	quick fix for old junction track
.noNameHover: true
	if true, do not render the left-side "hovering" item name when the item is clipped on both ends
	used for showing sections of gene model in bam read panel
.categories: { key: { color } }
	if provided, allows to decide color of a bed item based on its category
.hideItemNames: true
	if true, will delete item.name so they won't be rendered
.onerow: true
	if true, will render all items in a single row and do not stack them
	no matter the number of items
	otherwise, will decide dynamically with onerow_minitemcount
	currently only used for repeat masker track

*********************** structure of an item
.chr
.start
.stop
.rglst[ {idx} ]
.canvas{}
	The coordinates and attributes of items (i.e. exons and introns) and, 
	if applicable, the gene name/label. Necessary for event handlers, specifically click events
	and tooltip rendering. 
	.start // pixel position in canvas
	.stop
	.stranded
		if true, item.strand=+/-
	.namein
		if true, print name inside item box
	.namewidth // rendering width of a name
	.namestart // x position to print a name
	.namehover // if true, "hover" name on top of item, with a white bordered box as backdrop
	.textalign // how to align this name text, with value for ctx.textAlign

*********************** returned data
*/

const namespace = 1 // one pixel between the gene label name and the item structure
const namepad = 10 // box no struct: [pad---name---pad]
const packfull_cutoff = 400 //the number of items in the view range; below the cutoff will render in 'packfull' mode
const onerow_minitemcount = 600 // number of items exceeding this amount will all be rendered in one row
const returngmdata_maxCount = 50 // max number of items to return data to client

// color for translated codons
const altcolor = 'rgba(122,103,44,.7)',
	errcolor = 'red',
	startcolor = '#edad0c', //'rgba(0,255,0,.4)', // methionine
	stopcolor = 'rgba(255,0,0,.5)',
	skippedBpColor = '#ccc'

export default function (genomes) {
	return async (req, res) => {
		try {
			res.send(await do_query(req, genomes))
		} catch (e) {
			res.send({ error: e.message || e })
			if (e.stack) console.log(e.stack)
		}
	}
}

async function do_query(req, genomes) {
	const [e, tkfile, isurl] = utils.fileurl(req)
	if (e) throw e

	// append new boolean flag to req.query{}
	req.query.fileIsBigbed = await utils.testIfFileIsBigbed(tkfile)

	let stackheight, stackspace, regionspace, width, fontsize
	if (req.query.getdata) {
		// no rendering, return list of parsed items
		if (req.query.getBED) {
			// experimental parameter to pass over BED file items to clientside
		}
	} else {
		stackheight = Number(req.query.stackheight)
		stackspace = Number(req.query.stackspace)
		regionspace = Number(req.query.regionspace)
		width = Number(req.query.width)
		if (Number.isNaN(stackheight)) throw 'stackheight is not integer'
		fontsize = Math.max(10, stackheight - 2)
		if (Number.isNaN(stackspace)) throw 'stackspace is not integer'
		if (Number.isNaN(regionspace)) throw 'regionspace is not integer'
		// width could be float!!
		if (Number.isNaN(width)) throw 'width is not a number'
	}

	if (req.query.usevalue) {
		if (!req.query.usevalue.key) throw '.key missing from .usevalue'
		if (req.query.usevalue.dropBelowCutoff) {
			req.query.usevalue.dropBelowCutoff = Number(req.query.usevalue.dropBelowCutoff)
			if (Number.isNaN(req.query.usevalue.dropBelowCutoff)) throw '.usevalue.dropBelowCutoff is not number'
		}
	}

	if (req.query.bplengthUpperLimit) {
		req.query.bplengthUpperLimit = Number(req.query.bplengthUpperLimit)
		if (Number.isNaN(req.query.bplengthUpperLimit)) throw 'bplengthUpperLimit not number'
	}

	if (!req.query.genome) throw 'genome missing'
	const genomeobj = genomes[req.query.genome]
	if (!genomeobj) throw 'invalid genome'

	utils.validateRglst(req.query, genomeobj)
	for (const r of req.query.rglst) {
		// TODO validate regions
		if (r.reverse) {
			r.scale = p => Math.ceil((r.width * (r.stop - p)) / (r.stop - r.start))
		} else {
			r.scale = p => Math.ceil((r.width * (p - r.start)) / (r.stop - r.start))
		}
	}

	const color = req.query.color || '#3D7A4B'
	const flag_gm = req.query.gmregion || null
	const gmisoform = req.query.isoform
	const flag_onerow = req.query.onerow
	const categories = req.query.categories || null
	const __isgene = req.query.__isgene

	let dir
	if (!req.query.fileIsBigbed && isurl) {
		dir = await utils.cache_index(tkfile, req.query.indexURL)
	}

	const regionitems = await query_file(req.query, tkfile, dir, flag_gm, gmisoform)

	let filterByName
	if (req.query.filterByName) {
		filterByName = new Set(req.query.filterByName.split(/[\s\n]/).map(i => i.trim()))
	}

	const items = []

	// apply filtering
	for (const lst of regionitems) {
		for (const i of lst) {
			if (req.query.usevalue) {
				const v = i[req.query.usevalue.key]
				if (!Number.isFinite(v)) {
					continue
				}
				if (req.query.usevalue.dropBelowCutoff && v < req.query.usevalue.dropBelowCutoff) {
					continue
				}
			}
			if (req.query.bplengthUpperLimit && i.stop - i.start > req.query.bplengthUpperLimit) {
				continue
			}
			if (filterByName) {
				if (i.isoform) {
					if (!filterByName.has(i.isoform)) continue
				} else if (i.name) {
					if (!filterByName.has(i.name)) continue
				} else {
					// do not show nameless items in this case
					continue
				}
			}
			items.push(i)
		}
	}

	if (req.query.getdata) {
		///////////////////////// exit ///////////////////
		return { items }
	}

	if (items.length == 0) {
		const canvas = createCanvas(width * req.query.devicePixelRatio, stackheight * req.query.devicePixelRatio)
		const ctx = canvas.getContext('2d')
		if (req.query.devicePixelRatio > 1) ctx.scale(req.query.devicePixelRatio, req.query.devicePixelRatio)
		ctx.font = stackheight + 'px Arial'
		ctx.fillStyle = '#aaa'
		ctx.textAlign = 'center'
		ctx.textBaseline = 'middle'
		ctx.fillText('No data in view range', width / 2, stackheight / 2)
		///////////////////////// exit ///////////////////
		return {
			src: canvas.toDataURL(),
			height: stackheight
		}
	}

	const thinpad = Math.ceil(stackheight / 4) - 1

	if (flag_onerow || items.length >= onerow_minitemcount) {
		// render all items in a single row
		// do not show names
		// may render strand
		const notmanyitem = items.length < 200
		const canvas = createCanvas(width * req.query.devicePixelRatio, stackheight * req.query.devicePixelRatio)
		const ctx = canvas.getContext('2d')
		if (req.query.devicePixelRatio > 1) ctx.scale(req.query.devicePixelRatio, req.query.devicePixelRatio)
		const mapisoform = items.length <= 200 ? [] : null
		for (const item of items) {
			const fillcolor =
				categories && item.category && categories[item.category] ? categories[item.category].color : item.color || color
			ctx.fillStyle = fillcolor
			for (const _r of item.rglst) {
				let cumx = 0
				for (let i = 0; i < _r.idx; i++) {
					cumx += req.query.rglst[i].width + regionspace
				}
				const r = req.query.rglst[_r.idx]
				const thin = []
				if (item.utr5) {
					thin.push(...item.utr5)
				}
				if (item.utr3) {
					thin.push(...item.utr3)
				}
				if (item.exon && (!item.coding || item.coding.length == 0)) {
					thin.push(...item.exon)
				}
				for (const e of thin) {
					const a = Math.max(r.start, e[0])
					const b = Math.min(r.stop, e[1])
					const pxa = cumx + r.scale(r.reverse ? b : a)
					const pxb = cumx + r.scale(r.reverse ? a : b)
					ctx.fillRect(pxa, thinpad, Math.max(1, pxb - pxa), stackheight - thinpad * 2)
					bedj_may_mapisoform(mapisoform, pxa, pxb, 1, item)
				}
				const thick = []
				if (item.exon) {
					if (item.coding && item.coding.length > 0) {
						thick.push(...item.coding)
					}
				} else {
					thick.push([item.start, item.stop])
				}
				for (const e of thick) {
					const a = Math.max(r.start, e[0])
					const b = Math.min(r.stop, e[1])
					const pxa = cumx + r.scale(r.reverse ? b : a)
					const pxb = cumx + r.scale(r.reverse ? a : b)
					ctx.fillRect(pxa, 0, Math.max(1, pxb - pxa), stackheight)
					bedj_may_mapisoform(mapisoform, pxa, pxb, 1, item)
					if (item.strand && notmanyitem) {
						ctx.strokeStyle = 'white'
						strokearrow(ctx, item.strand, pxa, thinpad, pxb - pxa, stackheight - thinpad * 2)
					}
				}
			}
		}
		///////////////////////// exit ///////////////////
		return {
			src: canvas.toDataURL(),
			height: stackheight,
			mapisoform: mapisoform
		}
	}

	////////// render normally

	if (req.query.hideItemNames) {
		// delete item names to prevent them from showing
		for (const i of items) delete i.name
	}

	let returngmdata = null
	if (__isgene && items.length < returngmdata_maxCount) {
		// gene data requested and not too many, so return data
		returngmdata = []
		for (const i of items) {
			const j = {}
			for (const k in i) {
				if (k == 'canvas' || k == 'rglst') continue
				j[k] = i[k]
			}
			returngmdata.push(j)
		}
	}

	const bpcount = req.query.rglst.reduce((a, b) => a + b.stop - b.start, 0)
	const maytranslate = req.query.translatecoding && bpcount < width * 3
	const translateitem = []
	const canvas = createCanvas(10, 10) // for measuring text only
	let ctx = canvas.getContext('2d')
	if (req.query.devicePixelRatio > 1) ctx.scale(req.query.devicePixelRatio, req.query.devicePixelRatio)
	ctx.font = 'bold ' + fontsize + 'px Arial'

	const packfull = items.length < packfull_cutoff
	const mapisoform = items.length < packfull_cutoff ? [] : null
	// sort items
	// TODO from different chrs
	let sortreverse = false
	if (flag_gm) {
		sortreverse = flag_gm.reverse
	}
	for (const r of req.query.rglst) {
		if (r.reverse) {
			sortreverse = true
		}
	}

	items.sort((a, b) => {
		if (sortreverse) {
			if (a.stop == b.stop) {
				return a.start - b.start
			}
			return b.stop - a.stop
		} else {
			if (a.start == b.start) {
				return b.stop - a.stop
			}
			return a.start - b.start
		}
	})

	const hasstruct = items.some(i => i.exon)

	// stack
	const stack = [0]
	let maxstack = 1,
		mapexon = null

	for (const item of items) {
		// px position in the whole view range
		let itemstartpx = null,
			itemstoppx = null

		for (const _r of item.rglst) {
			let cumx = 0
			for (let i = 0; i < _r.idx; i++) {
				cumx += req.query.rglst[i].width + regionspace
			}
			const r = req.query.rglst[_r.idx]
			const a = Math.max(item.start, r.start)
			const b = Math.min(item.stop, r.stop)
			if (a < b) {
				// item in this region
				const pxa = cumx + r.scale(r.reverse ? b : a)
				const pxb = cumx + r.scale(r.reverse ? a : b)
				if (itemstartpx == null) {
					itemstartpx = pxa
					itemstoppx = pxb
				} else {
					itemstartpx = Math.min(itemstartpx, pxa)
					itemstoppx = Math.max(itemstoppx, pxb)
				}
			}
		}
		if (itemstartpx == null) {
			continue
		}
		item.canvas = {
			start: itemstartpx, //x1 coordinate position
			stop: itemstoppx, //x2 coordinate position
			stranded: item.strand != undefined
		}
		if (item.coding && maytranslate) {
			item.willtranslate = true // so later the strand will not show
			translateitem.push(item)
		}
		/* 
		if no name, boxstart and boxstop = the item start and stop, respectively. 
		if name, boxstart or boxstop will include the item name with item start or item stop, 
		as appropriate. See logic under `if (packfull)` below.
		*/
		let boxstart = itemstartpx
		let boxstop = itemstoppx
		if (packfull) {
			// check number of items; show item name if track not 'packed full' and name is available
			const namestr = item.name
			if (namestr) {
				// has name, will figure out where to show name
				item.canvas.namestr = namestr
				const namewidth = ctx.measureText(namestr).width
				item.canvas.namewidth = namewidth

				if (hasstruct) {
					/* item has structure, try not to overlay name on top of item
					an overlay occurs when the item extends past genome browser, 
					thus no room is available*/
					if (item.canvas.start >= namewidth + namespace) {
						// show name on the left side of item
						// x1 will include the item and the item label
						item.canvas.namestart = item.canvas.start - namespace
						boxstart = item.canvas.namestart - namewidth
						item.canvas.textalign = 'right'
					} else if (item.canvas.stop + namewidth + namespace <= width) {
						// show name on the right side of item
						// x2 will include the item and the item label
						item.canvas.namestart = item.canvas.stop + namespace
						boxstop = item.canvas.namestart + namewidth
						item.canvas.textalign = 'left'
					} else {
						// not enough space on left and right
						if (namewidth > item.canvas.stop - item.canvas.start) {
							// name is wider than the item itself, do not hover
							// show on the wider side
							if (item.canvas.start > width - item.canvas.stop) {
								// space on left is wider
								item.canvas.namestart = item.canvas.start - namespace
								boxstart = item.canvas.namestart - namewidth
								item.canvas.textalign = 'right'
							} else {
								// space on right is wider
								item.canvas.namestart = item.canvas.stop + namespace
								boxstop = item.canvas.namestart + namewidth
								item.canvas.textalign = 'left'
							}
						} else {
							// name can fit into item, allow hover
							item.canvas.namehover = true
							item.canvas.textalign = 'left'
						}
					}
				} else {
					if (Math.min(width, item.canvas.stop) - Math.max(0, item.canvas.start) >= namewidth + namepad * 2) {
						item.canvas.namein = true
					} else if (item.canvas.start >= namewidth + namespace) {
						// show name on the left side of item
						item.canvas.namestart = item.canvas.start - namespace
						boxstart = item.canvas.namestart - namewidth
						item.canvas.textalign = 'right'
					} else if (item.canvas.stop + namewidth + namespace <= width) {
						// show name on the right side of item
						item.canvas.namestart = item.canvas.stop + namespace
						boxstop = item.canvas.namestart + namewidth
						item.canvas.textalign = 'left'
					} else {
						// why??
						item.canvas.namein = true
					}
				}
			}
		}
		if (item.canvas.stop - item.canvas.start > width * 0.3) {
			// enable
			mapexon = []
		}
		for (let i = 1; i <= maxstack; i++) {
			if (stack[i] == undefined || stack[i] < boxstart) {
				item.canvas.stack = i
				stack[i] = boxstop
				break
			}
		}
		if (item.canvas.stack == undefined) {
			maxstack++
			stack[maxstack] = boxstop
			item.canvas.stack = maxstack
		}
		bedj_may_mapisoform(mapisoform, boxstart, boxstop, item.canvas.stack, item)
	}

	// render

	canvas.width = width * req.query.devicePixelRatio
	const finalheight = (stackheight + stackspace) * maxstack - stackspace
	canvas.height = finalheight * req.query.devicePixelRatio
	ctx = canvas.getContext('2d')
	if (req.query.devicePixelRatio > 1) ctx.scale(req.query.devicePixelRatio, req.query.devicePixelRatio)
	ctx.font = 'bold ' + fontsize + 'px Arial'
	ctx.textBaseline = 'middle'
	ctx.lineWidth = 1

	for (const item of items) {
		// render an item

		const c = item.canvas
		if (!c) {
			// invisible item
			continue
		}
		const fillcolor =
			categories && item.category && categories[item.category] ? categories[item.category].color : item.color || color
		const y = (stackheight + stackspace) * (c.stack - 1)
		ctx.fillStyle = fillcolor
		if (item.exon || item.rglst.length > 1) {
			// through line
			ctx.strokeStyle = fillcolor
			ctx.beginPath()
			ctx.moveTo(c.start, Math.floor(y + stackheight / 2) + 0.5)
			ctx.lineTo(c.stop, Math.floor(y + stackheight / 2) + 0.5)
			ctx.stroke()
		}
		for (const _r of item.rglst) {
			let cumx = 0
			for (let i = 0; i < _r.idx; i++) {
				cumx += req.query.rglst[i].width + regionspace
			}
			const region = req.query.rglst[_r.idx]
			const thinbox = []
			if (item.utr3) {
				thinbox.push(...item.utr3)
			}
			if (item.utr5) {
				thinbox.push(...item.utr5)
			}
			if (item.exon && (!item.coding || item.coding.length == 0)) {
				thinbox.push(...item.exon)
			}
			for (const e of thinbox) {
				const a = Math.max(e[0], region.start)
				const b = Math.min(e[1], region.stop)
				if (a < b) {
					if (item.exon2color) {
						for (const f of item.exon2color) {
							if (a >= f.start && b <= f.stop) {
								ctx.fillStyle = f.color // temporarily use the given color for this exon
								break
							}
						}
					}

					const pxa = cumx + region.scale(region.reverse ? b : a)
					const pxb = cumx + region.scale(region.reverse ? a : b)
					ctx.fillRect(pxa, y + thinpad, Math.max(1, pxb - pxa), stackheight - thinpad * 2)

					if (item.exon2color) ctx.fillStyle = fillcolor // restore color
				}
			}
			const thick = []
			if (item.exon) {
				if (item.coding && item.coding.length > 0) {
					thick.push(...item.coding)
				}
			} else {
				thick.push([item.start, item.stop])
			}
			let _strand = item.strand
			if (c.stranded && region.reverse) {
				_strand = item.strand == '+' ? '-' : '+'
			}
			for (const e of thick) {
				const a = Math.max(e[0], region.start)
				const b = Math.min(e[1], region.stop)
				if (a < b) {
					if (item.exon2color) {
						for (const f of item.exon2color) {
							if (a >= f.start && b <= f.stop) {
								ctx.fillStyle = f.color // temporarily use the given color for this exon
								break
							}
						}
					}

					const pxa = cumx + region.scale(region.reverse ? b : a)
					const pxb = cumx + region.scale(region.reverse ? a : b)
					ctx.fillRect(pxa, y, Math.max(1, pxb - pxa), stackheight)

					if (item.exon2color) ctx.fillStyle = fillcolor // restore color

					// strand marks inside box

					if (c.stranded && !item.willtranslate) {
						ctx.strokeStyle = 'white'

						if (c.namein) {
							/*
						patch!!!
						to acknowledge name inside box cases
						this always happens to a singular item with no exon structure
						*/
							const w = (pxb - pxa - c.namewidth) / 2
							strokearrow(ctx, _strand, pxa, y + thinpad, w, stackheight - thinpad * 2)
							strokearrow(ctx, _strand, pxa + w + c.namewidth, y + thinpad, w, stackheight - thinpad * 2)
						} else {
							strokearrow(ctx, _strand, pxa, y + thinpad, pxb - pxa, stackheight - thinpad * 2)
						}
					}
				}
			}
			if (c.stranded && item.intron) {
				// intron arrows
				ctx.strokeStyle = fillcolor
				for (const e of item.intron) {
					const a = Math.max(e[0], region.start)
					const b = Math.min(e[1], region.stop)
					if (a < b) {
						const pxa = cumx + region.scale(region.reverse ? b : a)
						const pxb = cumx + region.scale(region.reverse ? a : b)
						strokearrow(ctx, _strand, pxa, y + thinpad, pxb - pxa, stackheight - thinpad * 2)
					}
				}
			}
			if (mapexon && item.exon) {
				for (let i = 0; i < item.exon.length; i++) {
					const e = item.exon[i]
					if (e[1] <= region.start || e[0] >= region.stop) continue
					const a = Math.max(e[0], region.start)
					const b = Math.min(e[1], region.stop)
					if (a < b) {
						const x1 = cumx + region.scale(region.reverse ? b : a)
						const x2 = cumx + region.scale(region.reverse ? a : b)
						mapexon.push({
							chr: item.chr,
							start: Math.min(e[0], e[1]),
							stop: Math.max(e[0], e[1]),
							x1: x1,
							x2: x2,
							y: c.stack,
							name: 'Exon ' + (i + 1) + '/' + item.exon.length
						})
					}
				}
				for (let i = 1; i < item.exon.length; i++) {
					const istart = item.exon[item.strand == '+' ? i - 1 : i][1],
						istop = item.exon[item.strand == '+' ? i : i - 1][0]
					if (istop <= region.start || istart >= region.stop) continue
					const a = Math.max(istart, region.start)
					const b = Math.min(istop, region.stop)
					if (a < b) {
						const x1 = cumx + region.scale(region.reverse ? b : a)
						const x2 = cumx + region.scale(region.reverse ? a : b)
						if (x2 < 0) continue
						mapexon.push({
							chr: item.chr,
							start: istart,
							stop: istop,
							x1: x1,
							x2: x2,
							y: c.stack,
							name: 'Intron ' + i + '/' + (item.exon.length - 1)
						})
					}
				}
			}
		}
		// name
		if (c.namestart != undefined) {
			ctx.textAlign = c.textalign
			ctx.fillStyle = fillcolor
			ctx.fillText(c.namestr, c.namestart, y + stackheight / 2)
		} else if (c.namehover && !req.query.noNameHover) {
			const x = Math.max(10, c.start + 10)
			ctx.fillStyle = 'white'
			ctx.fillRect(x, y, c.namewidth + 10, stackheight)
			ctx.strokeStyle = fillcolor
			ctx.strokeRect(x + 1.5, y + 0.5, c.namewidth + 10 - 3, stackheight - 2)
			ctx.fillStyle = fillcolor
			ctx.textAlign = 'center'
			ctx.fillText(c.namestr, x + c.namewidth / 2 + 5, y + stackheight / 2)
		} else if (c.namein) {
			ctx.textAlign = 'center'
			ctx.fillStyle = 'white'
			ctx.fillText(c.namestr, (Math.max(0, c.start) + Math.min(width, c.stop)) / 2, y + stackheight / 2)
		}
	}

	const result = {
		height: finalheight,
		mapisoform,
		mapexon,
		returngmdata
	}
	if (translateitem.length == 0) {
		// nothing to be translated
		result.src = canvas.toDataURL()
		return result
	}
	// have genes to be translated
	const mapaa = []

	ctx.textAlign = 'center'
	ctx.textBaseline = 'middle'
	for (const [i, item] of translateitem.entries()) {
		// need i
		const fillcolor =
			categories && item.category && categories[item.category] ? categories[item.category].color : item.color || color
		const c = item.canvas
		const y = (stackheight + stackspace) * (c.stack - 1)
		item.genomicseq = (await utils.get_fasta(genomeobj, item.chr + ':' + (item.start + 1) + '-' + item.stop))
			.split('\n')
			.slice(1)
			.join('')
			.toUpperCase()
		const aaseq = nt2aa(item)
		for (const _r of item.rglst) {
			const region = req.query.rglst[_r.idx]
			let cumx = 0
			for (let j = 0; j < _r.idx; j++) {
				cumx += req.query.rglst[j].width + regionspace
			}
			const bppx = region.width / (region.stop - region.start)
			const _fs = Math.min(stackheight, bppx * 3)
			const aafontsize = _fs < 8 ? null : _fs // if a codon is too narrow, won't draw aa letter
			let minustrand = false
			if (c.stranded && item.strand == '-') {
				minustrand = true
			}
			let cds = 0 // cumulative #bp thus seen, for coding exons
			if (aafontsize) {
				ctx.font = aafontsize + 'px Arial'
			}
			for (const [e_idx, e] of item.coding.entries()) {
				// each exon, they are ordered 5' to 3'
				// e0/e1 for translatable bp range of this exon; may be modified for non-default reading frame
				let [e0, e1] = e

				if (minustrand) {
					if (e0 >= region.stop) {
						// e is not yet in view range
						cds += e1 - e0
						if (e_idx == 0 && item.startCodonFrame) {
							cds -= 3 - item.startCodonFrame // see below
						}
						continue
					}
					if (e1 <= region.start) {
						// e is out of view range
						break
					}
				} else {
					if (e1 <= region.start) {
						// e is not yet in view range
						cds += e1 - e0
						if (e_idx == 0 && item.startCodonFrame) {
							cds -= 3 - item.startCodonFrame
						}
						continue
					}
					if (e0 >= region.stop) {
						// e is out of view range
						break
					}
				}

				// this exon "e" overlaps with view range; will print codon on it

				if (e_idx == 0 && item.startCodonFrame) {
					// this is first coding exon and the gene is not using default frame;
					// must skip 1 or 2 bp from 5' of this exon, thus adding to e0 or removing from e1
					if (minustrand) {
						e1 -= 3 - item.startCodonFrame
					} else {
						e0 += 3 - item.startCodonFrame
					}
					// now fill gray to the basepairs skipped from 5' end of this exon
					let a = Math.max(e[0], region.start),
						b = Math.min(e[1], region.stop)
					if (minustrand) {
						a = Math.max(e1, region.start)
					} else {
						b = Math.min(e0, region.stop)
					}
					if (a < b) {
						ctx.fillStyle = skippedBpColor
						const pxa = cumx + region.scale(region.reverse ? b : a)
						const pxb = cumx + region.scale(region.reverse ? a : b)
						ctx.fillRect(pxa, y, Math.max(1, pxb - pxa), stackheight)
					}
				}

				const lookstart = Math.max(region.start, e0),
					lookstop = Math.min(region.stop, e1)
				if (minustrand) {
					cds += e1 - lookstop
				} else {
					cds += lookstart - e0
				}

				let codonspan = 0

				for (let k = 0; k < lookstop - lookstart; k++) {
					// each coding base
					cds++
					codonspan++
					let aanumber
					if (cds % 3 == 0) {
						aanumber = cds / 3 - 1
					} else {
						if (k < lookstop - lookstart - 1) {
							continue
						} else {
							// at the 3' end of this exon
							aanumber = Math.floor(cds / 3)
						}
					}
					let aa = aaseq[aanumber],
						_fillcolor = Math.ceil(cds / 3) % 2 == 0 ? altcolor : null
					if (!aa) {
						aa = 4 // show text "4" to indicate error
						_fillcolor = errcolor
					} else if (aa == 'M') {
						_fillcolor = startcolor
					} else if (aa == '*') {
						_fillcolor = stopcolor
					}
					// draw aa
					let thispx,
						thiswidth = bppx * codonspan
					if (minustrand) {
						const thispos = lookstop - 1 - k
						thispx = cumx + region.scale(thispos)
					} else {
						const thispos = lookstart + k + 1 - codonspan
						thispx = cumx + region.scale(thispos)
					}
					if (region.reverse) {
						// correction!
						thispx -= thiswidth
					}
					codonspan = 0
					if (thispx >= cumx && thispx <= cumx + region.width) {
						// in view range
						// rect
						if (_fillcolor) {
							ctx.fillStyle = _fillcolor
							ctx.fillRect(thispx, y, thiswidth, stackheight)
						}
						if (aafontsize) {
							ctx.fillStyle = 'white'
							ctx.fillText(aa, thispx + thiswidth / 2, y + stackheight / 2)
						}
						mapaa.push({
							x1: thispx,
							x2: thispx + thiswidth,
							y: item.canvas.stack,
							name: aa + (aanumber + 1) + ' <span style="font-size:.7em;color:#858585">AA residue</span>'
						})
					}
				}
			}
		}
		if (c.namehover && !req.query.noNameHover) {
			ctx.font = 'bold ' + fontsize + 'px Arial'
			const x = Math.max(10, c.start + 10)
			ctx.fillStyle = 'white'
			ctx.fillRect(x, y, c.namewidth + 10, stackheight)
			ctx.strokeStyle = fillcolor
			ctx.strokeRect(x + 1.5, y + 0.5, c.namewidth + 10 - 3, stackheight - 2)
			ctx.fillStyle = fillcolor
			ctx.fillText(c.namestr, x + c.namewidth / 2 + 5, y + stackheight / 2)
		}
	}
	// done translating
	result.src = canvas.toDataURL()
	result.mapaa = mapaa
	return result
}

function bedj_may_mapisoform(lst, boxstart, boxstop, y, item) {
	/* only handle singular bed items, or entire isoform
do not handle exon/intron parts
may return additional info for:
- creating url for clicking items
*/
	if (!lst) return // not to map
	if (!item.name && !item.isoform) return // no name
	const show = []
	if (item.name) show.push(item.name)
	if (item.isoform) show.push(item.isoform)
	lst.push({
		// return position for displaying in tooltip
		chr: item.chr,
		start: item.start,
		stop: item.stop,
		x1: boxstart, //item x1 coordinate; if applicable includes the label width & namespace
		x2: boxstop, //item x2 coordinate; if applicable includes the label width & namespace
		y: y, // stack number
		/* isoform is for client to select one and launch protein view
		 */
		isoform: item.isoform,
		//name:show.join(' ')+printcoord(item.chr, e[0], e[1])
		name: show.join(' ')
	})
}

/*
input:

q={}
	.fileIsBigbed=boolean
tkfile=full path
dir=
flag_gm={ chr, start, stop }
	undefined if track is not displayed on a gene
gmisoform=string
	accession of an isoform. if given, will filter items by item.isoform

output:

array of objects, each object is one bed item
*/
async function query_file(q, tkfile, dir, flag_gm, gmisoform) {
	// if set, content is last bed file line with invalid json string in 4th column, to throw exception
	let invalidJsonLine

	if (flag_gm) {
		// query over the gene region, just one region
		const items = []

		if (q.fileIsBigbed) {
			const lines = await utils.query_bigbed_by_coord(tkfile, flag_gm.chr, flag_gm.start, flag_gm.stop)
			for (const line of lines) {
				const l = line.split('\t')

				// create one object for the line from the bigbed file
				const j = parseBedLine(l)

				// helper function does not add chr/start/stop/rglst
				j.chr = l[0]
				j.start = Number(l[1])
				j.stop = Number(l[2])
				j.rglst = []
				for (let i = 0; i < q.rglst.length; i++) {
					const r = q.rglst[i]
					// simply decide by the whole gene span, not by exons, otherwise there will result in gaps
					if (Math.max(j.start, r.start) < Math.min(j.stop, r.stop)) {
						j.rglst.push({ idx: i })
					}
				}
				if (j.rglst.length == 0) continue

				items.push(j)
			}
		} else {
			await utils.get_lines_bigfile({
				args: [tkfile, flag_gm.chr + ':' + flag_gm.start + '-' + flag_gm.stop],
				dir,
				callback: line => {
					const l = line.split('\t')
					let j = {}
					if (q.getBED) {
						j.rest = l.slice(3)
					} else if (l[3]) {
						try {
							j = JSON.parse(l[3])
						} catch (e) {
							invalidJsonLine = line
							return
						}
					}
					if (j.isoformonly && j.isoformonly != gmisoform) {
						// this is specific for what? idr per isoforms?
						return
					}
					j.chr = l[0]
					j.start = Number(l[1])
					j.stop = Number(l[2])

					// TODO clarify reason
					j.rglst = []
					for (let i = 0; i < q.rglst.length; i++) {
						const r = q.rglst[i]
						// simply decide by the whole gene span, not by exons, otherwise there will result in gaps
						if (Math.max(j.start, r.start) < Math.min(j.stop, r.stop)) {
							j.rglst.push({ idx: i })
						}
					}
					if (j.rglst.length == 0) return
					items.push(j)
				}
			})
		}

		if (invalidJsonLine) throw 'Line with invalid JSON: ' + invalidJsonLine

		return [items] // nothing wrong
	}

	// query over genomic regions
	// each item belong to only one region
	const regions = []

	for (const [idx, r] of q.rglst.entries()) {
		const itemofthisregion = []

		if (q.fileIsBigbed) {
			const lines = await utils.query_bigbed_by_coord(tkfile, r.chr, r.start, r.stop)
			for (const line of lines) {
				const l = line.split('\t')

				// create one object for the line from the bigbed file
				const j = parseBedLine(l)

				// helper function does not add chr/start/stop/rglst
				j.chr = l[0]
				j.start = Number(l[1])
				j.stop = Number(l[2])
				j.rglst = [{ idx }] // can help with rendering later

				itemofthisregion.push(j)
			}
		} else {
			await utils.get_lines_bigfile({
				args: [tkfile, r.chr + ':' + r.start + '-' + r.stop],
				dir,
				callback: line => {
					const l = line.split('\t')

					// create one object for the bed item
					let j = {}

					if (q.getBED) {
						j.rest = l.slice(3)
					} else if (l[3]) {
						try {
							j = JSON.parse(l[3])
						} catch (e) {
							invalidJsonLine = line
							return
						}
					}
					j.chr = l[0]
					j.start = Number(l[1])
					j.stop = Number(l[2])
					j.rglst = [{ idx }] // can help with rendering later
					itemofthisregion.push(j)
				}
			})
		}

		regions.push(itemofthisregion)
	}

	if (invalidJsonLine) throw 'Line with invalid JSON: ' + invalidJsonLine

	return regions
}

function strokearrow(ctx, strand, x, y, w, h) {
	const pad = h / 2,
		arrowwidth = h / 2,
		arrowpad = Math.max(h / 2, 6)
	if (w - pad * 2 < arrowwidth) return
	const arrownum = Math.ceil((w - pad * 2) / (arrowwidth + arrowpad))
	if (arrownum <= 0) return
	const forward = strand == '+'
	let x0 = Math.ceil(x + (w - arrowwidth * arrownum - arrowpad * (arrownum - 1)) / 2)
	for (let i = 0; i < arrownum; i++) {
		ctx.beginPath()
		if (forward) {
			ctx.moveTo(x0, y)
			ctx.lineTo(x0 + arrowwidth, y + h / 2)
			ctx.moveTo(x0 + arrowwidth, y + h / 2 + 1)
			ctx.lineTo(x0, y + h)
		} else {
			ctx.moveTo(x0 + arrowwidth, y)
			ctx.lineTo(x0, y + h / 2)
			ctx.moveTo(x0, y + h / 2 + 1)
			ctx.lineTo(x0 + arrowwidth, y + h)
		}
		ctx.stroke()
		x0 += arrowwidth + arrowpad
	}
}
