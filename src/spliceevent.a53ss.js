
exports.findalternativeSSevents=function(lst)
{

/*
lst[]  list of junctions

as generated by mapjunctiontoexons()

.matchisoform[]
.exonleft
.exonright
.exonleftin
.exonrightin
.intronleft
.intronright
.leftout
.rightout

*/


const events=[]

for(const j of lst) {
	
	// tell if this junction match a known intron by matchisoform[]
	let iscanonical=false
	for(const m of j.matchisoform) {
		if(Math.abs(m.leftexonidx-m.rightexonidx)==1) {
			iscanonical=true
			break
		}
	}
	if(iscanonical) {
		continue
	}

	for(const leftpoint of j.exonleft) {
		const gm=leftpoint.gm
		const forward=gm.strand=='+'
		for(const rightpoint of j.exonrightin) {
			if(rightpoint.gm.isoform==gm.isoform && rightpoint.exonidx==leftpoint.exonidx+(forward?1:-1)) {

				const e={
					gm: gm,
					junctionB: j,
					altinexon: true,
					sitedist: Math.abs(j.stop-gm.exon[rightpoint.exonidx][0])
				}
				if(forward) {
					e.a3ss=true
					e.exon5idx=leftpoint.exonidx
				} else {
					e.a5ss=true
					e.exon5idx=rightpoint.exonidx
				}
				events.push(e)
			}
		}
		for(const rightpoint of j.intronright) {
			if(rightpoint.gm.isoform==gm.isoform && rightpoint.intronidx==leftpoint.exonidx-(forward?0:1)) {
				const e={
					gm:gm,
					junctionB:j,
					altinintron:true,
					sitedist: Math.abs(j.stop-gm.intron[rightpoint.intronidx][1])
				}
				if(forward) {
					e.a3ss=true
					e.exon5idx=leftpoint.exonidx
				} else {
					e.a5ss=true
					e.exon5idx=rightpoint.intronidx
				}
				events.push(e)
			}
		}
	}

	for(const right of j.exonright) {
		const gm=right.gm
		const forward=gm.strand=='+'
		for(const left of j.exonleftin) {
			if(left.gm.isoform==gm.isoform && left.exonidx==right.exonidx-(forward?1:-1)) {
				const e={
					gm:gm,
					junctionB:j,
					altinexon:true,
					sitedist: Math.abs(j.start-gm.exon[left.exonidx][1])
				}
				if(forward) {
					e.a5ss=true
					e.exon5idx=left.exonidx
				} else {
					e.a3ss=true
					e.exon5idx=right.exonidx
				}
				events.push(e)
			}
		}
		for(const left of j.intronleft) {
			if(left.gm.isoform==gm.isoform && left.intronidx==right.exonidx-(forward?1:0)) {
				const e={
					gm:gm,
					junctionB:j,
					altinintron:true,
					sitedist: Math.abs(j.start-(gm.intron[left.intronidx][0]-1))
				}
				if(forward) {
					e.a5ss=true
					e.exon5idx=left.intronidx
				} else {
					e.a3ss=true
					e.exon5idx=right.exonidx
				}
				events.push(e)
			}
		}
	}
}

// find canonical junction for each event
for(const e of events) {
	// canonical junction must span intron e.exon5idx
	const intron = e.gm.intron[e.exon5idx]
	let jA
	for(const j of lst) {
		if(j.start==intron[0]-1 && j.stop==intron[1]) {
			jA=j
			break
		}
	}
	if(jA) {
		e.junctionA=jA
		e.percentage = Math.ceil(100*e.junctionB.data[0].v/(e.junctionB.data[0].v+jA.data[0].v))
	} else {
		e.percentage=100
	}
}
return events
}
