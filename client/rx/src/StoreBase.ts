import { type AppApi } from './AppApi'

export class StoreBase {
	type: string = 'store'
	app: AppApi
	//type: string
	//id: string
	opts: any
	id: string
	state: any
	// dom: any
	// config: any

	/** use for assigning unique IDs where needed
	 * may be used later to simplify getting component state by type and id */
	prevGeneratedId = 0

	// the action.sequenceId can be used by a chart/app
	// to identify the state that corresponds to an async step
	// like a server data request, so that a really late-arriving data
	// can be rejected if the state that was associated with that requested
	// is already stale/superseded by a subsequent state update
	sequenceId: number = 0

	numPromisedWrites: number = 0

	constructor(opts) {
		this.opts = this.validateOpts(opts)
		this.app = this.opts.app
		this.id = opts.id
	}

	validateOpts(o: any = {}) {
		return o
	}

	fromJson(objStr) {
		// this base method should not be reused when there is
		// a need to recover any Set or Map values, instead
		// declare a class specific fromJson() method that has
		// new Set(arrOfValues) or new Map(arrOfPairedValues)
		//
		// also, do not use this when autogenerated IDs
		// need to be attached to list entries
		//
		return JSON.parse(objStr)
	}

	toJson(this: any, obj: any = null) {
		// this base method should not be reused when there is
		// a need to stringify any Set or Map values,
		// instead declare a class specific toJson() method
		// that converts any Set or Map values to
		// [...Set] or [...Map] before JSON.stringify()
		return JSON.stringify(obj ? obj : this.state)
	}

	deepFreeze(obj) {
		Object.freeze(obj)
		for (const key in obj) {
			if (typeof obj == 'object') this.deepFreeze(obj[key])
		}
	}

	copyMerge(base, ...args) {
		const target = typeof base == 'string' ? this.fromJson(base) : base
		for (const arg of args) {
			if (arg) {
				const source = typeof base == 'string' ? this.fromJson(this.toJson(arg)) : arg
				for (const key in source) {
					if (
						!target[key] ||
						Array.isArray(target[key]) ||
						typeof target[key] !== 'object' ||
						source === null ||
						source === undefined ||
						source.isAtomic ||
						target?.isAtomic ||
						target[key]?.isAtomic
					)
						target[key] = source[key]
					else this.copyMerge(target[key], source[key])
				}
			}
		}
		return target
	}
}
