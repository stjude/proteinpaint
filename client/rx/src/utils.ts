export function deepEqual(x, y) {
	if (x === y) {
		return true
	} else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {
		if (Object.keys(x).length != Object.keys(y).length) {
			return false
		}
		const xKeys = Object.keys(x)
		const yKeys = Object.keys(y)
		for (const prop of xKeys) {
			if (yKeys.includes(prop)) {
				if (!deepEqual(x[prop], y[prop])) return false
			} else {
				return false
			}
		}
		return true
	} else return false
}

export function deepFreeze(obj) {
	Object.freeze(obj)
	for (const key in obj) {
		if (typeof obj == 'object') deepFreeze(obj[key])
	}
}

export async function notifyComponents(components, current) {
	if (!components) return // allow component-less app
	const called: any[] = []

	for (const name of Object.keys(components)) {
		// when components is array, name will be index
		const component = components[name]
		if (Array.isArray(component)) {
			for (const c of component) called.push(c.update(current))
		} else if (typeof component == 'object') {
			if (typeof component.update == 'function') {
				called.push(component.update(current))
			} else if (!component.main) {
				for (const subname of Object.keys(component)) {
					if (typeof component[subname] == 'object' && typeof component[subname]?.update == 'function') {
						called.push(component[subname].update(current))
					}
				}
			}
		}
	}
	return Promise.all(called)
}

// Store Helpers
// -------------

/*
	base: 
	- either a state object or its JSON-stringified equivalent 
	- will be over-written by second+ argument,
	  similar to native Object.assign() overwrite sequence

	args
	- full or partial state object(s). if base is a string, then
	  the arg object will be converted to/from JSON to
	  create a copy for merging
	- the last argument may be an array of keys to force replacing
	  an object value instead of extending it

	Merging behavior:
	- a base value that is an array or non-object will be replaced by matching arg key-value
	- a base value that is an object will be extended by a matching arg key-value
	- nested base object values will be extended recursively, instead of being swapped/replaced
	  at the root level *** EXCEPT IF there is an isAtomic flag on one of these ****
	  - the source
	  - target object
	  - target child object
	- see index.spec test for copyMerge details
*/
export function copyMerge(base, ...args) {
	const target = typeof base == 'string' ? fromJson(base) : base
	for (const arg of args) {
		if (arg) {
			const source = typeof base == 'string' ? fromJson(toJson(arg)) : arg
			for (const key in source) {
				if (
					!target[key] ||
					Array.isArray(target[key]) ||
					typeof target[key] !== 'object' ||
					source === null ||
					source === undefined ||
					source.isAtomic ||
					target?.isAtomic ||
					target[key]?.isAtomic
				)
					target[key] = source[key]
				else copyMerge(target[key], source[key])
			}
		}
	}
	return target
}

export function fromJson(objStr) {
	// this method should not be reused when there is
	// a need to recover any Set or Map values, instead
	// declare a class specific fromJson() method that has
	// new Set(arrOfValues) or new Map(arrOfPairedValues)
	//
	// also, do not use this when autogenerated IDs
	// need to be attached to list entries
	//
	return JSON.parse(objStr)
}

export function toJson(this: any, obj = null) {
	// this method should not be reused when there is
	// a need to stringify any Set or Map values,
	// instead declare a class specific toJson() method
	// that converts any Set or Map values to
	// [...Set] or [...Map] before JSON.stringify()
	return JSON.stringify(obj ? obj : this.state)
}

export function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms))
}
