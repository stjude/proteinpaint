import * as client from './client'

/*
shared code for all mds tracks
only for mdsjunction and mdscnv
may be obsolete
*/

export function makeLegend_cohort_hierarchy(arg) {
	/*
	.hash {k:{}}
		generated by server, according to ds.cohort.hierarchies
		k: hierarchy.name
		v: list of nodes for this hierarchy
	.tk
	.block
	.makenodelabel()

	only works for parent track
	*/

	for (const hierarchyname in arg.hash) {
		// hierarchyname is .name of a hierarchy from ds.cohort
		const tr = arg.tk.cohortFilter.holderTable.append('tr')
		tr.append('td')
			.style('vertical-align', 'top')
			.append('div')
			.text(hierarchyname)
			.style('color', '#858585')
			.style('margin-top', '7px')
		const treeholder = tr.append('td').append('div').style('display', 'inline-block') // so that row won't expand to full

		let folderstack = []

		const nodesofhierarchy = []
		// v: {showhidebutton}

		for (const node of arg.hash[hierarchyname]) {
			/*
			.name
			.label
			.isleaf
			.depth
				depth=0 is root, ignored
				depth-1 is array index of hierarchy.levels
			.count
			.totalCount
			*/
			if (node.depth == 0) {
				// root
				continue
			}

			if (node.depth == 1) {
				// depth 1, show by default
				const [folder, showhidebutton] = make_one_node(arg, node, treeholder, hierarchyname)
				if (folder) {
					folderstack = [folder]
				}
				nodesofhierarchy.push({
					nodeid: node.id,
					showhidebutton: showhidebutton
				})
				continue
			}

			// children levels, find its own holder
			const itsholder = folderstack[node.depth - 2]
			const [folder, showhidebutton] = make_one_node(arg, node, itsholder, hierarchyname)
			if (folder) {
				folderstack[node.depth - 1] = folder
			}
			nodesofhierarchy.push({
				nodeid: node.id,
				showhidebutton: showhidebutton
			})
		}

		arg.tk.cohortFilter.hierarchies.keys[hierarchyname].allnodes = nodesofhierarchy
	}
}

function make_one_node(arg, node, holder, hierarchyname) {
	const row = holder.append('div')

	const labeldiv = row.append('div').style('display', 'inline-block').style('margin-right', '10px')
	arg.makenodelabel(node, labeldiv)

	/*
	show/hide button
	*/
	const showhidebutton = row
		.append('div')
		.style('display', 'inline-block')
		.attr('class', 'sja_handle_green')
		.text('SHOW')
		.style('font-size', '.8em')
		.on('mousedown', event => {
			event.stopPropagation()
		})
		.on('click', event => {
			event.stopPropagation()
			arg.clicknode(node, hierarchyname)
		})
	// search against tk.subTracks to detect if this node has been shown as a custom track
	if (arg.tk.subTracks.find(i => i.permanentHierarchy.nodeid == node.id)) {
		// the node has already been shown as a subtrack of this track
		showhidebutton.text('HIDE').attr('class', 'sja_handle_red')
	}

	// if not leaf, make a folder to show its leaf nodes
	let folder

	if (node.isleaf) {
		row.style('padding', '5px 10px') // must follow sja_clb padding
	} else {
		row.attr('class', 'sja_clb').on('click', () => {
			if (folder.style('display') == 'none') {
				arg.tk.cohortFilter.hierarchies.keys[hierarchyname].opennodeids.add(node.id)
				client.appear(folder)
				return
			}
			client.disappear(folder)
			arg.tk.cohortFilter.hierarchies.keys[hierarchyname].opennodeids.delete(node.id)
		})

		folder = holder
			.append('div')
			.style('display', arg.tk.cohortFilter.hierarchies.keys[hierarchyname].opennodeids.has(node.id) ? 'block' : 'none')
			.style('margin-left', '20px')
			.style('border-left', 'solid 1px ' + arg.block.legend.legendcolor)
			.style('padding-left', '5px')
			.style('background', 'white')
	}
	return [folder, showhidebutton]
}

export function showHideSubtrack_byHierarchyLevel(parentTk, block, hierarchy) {
	/*
	called by clicking on the Show/hide button of a node in a hierarchy

	given the node id, decide if to show it as a subtrack or hide it
	may show subtrack for a subset of samples
	hierarchy is used, from which a level & value is used to define the sample set

	hierarchy {}
		.hierarchyname
		.levelidx
		.valuekey
		.valuelabel
		.nodeid

	*/

	const arridx = parentTk.subTracks.findIndex(i => i.permanentHierarchy.nodeid == hierarchy.nodeid)
	if (arridx != -1) {
		// the node is already shown as a subtrack, remove it
		const subtkid = parentTk.subTracks[arridx].tkid
		parentTk.subTracks.splice(arridx, 1)
		block.tk_remove(block.tklst.findIndex(i => i.tkid == subtkid))
		parentTk.cohortFilter.hierarchies.keys[hierarchy.hierarchyname].allnodes
			.find(i => i.nodeid == hierarchy.nodeid)
			.showhidebutton.text('SHOW')
			.attr('class', 'sja_handle_green')
		return
	}

	const tktemp = {}
	{
		// template from parent.mds.queries
		// tk0 should be read-only, also contain default customizable settings, which should be overriden by what's in parent track
		const tk0 = parentTk.mds.queries[parentTk.querykey]
		for (const k in tk0) {
			tktemp[k] = tk0[k]
		}
		switch (tk0.type) {
			case client.tkt.mdsjunction:
				tktemp.readcountCutoff = parentTk.readcountCutoff
				tktemp.axisheight = parentTk.axisheight
				tktemp.legheight = parentTk.legheight
				tktemp.yscaleUseLog = parentTk.yscaleUseLog
				break
		}
	}

	const subtk = block.block_addtk_template(tktemp)

	// will override cohortHiddenAttr, and permanent fix for the subtrack
	subtk.permanentHierarchy = hierarchy

	delete subtk.subTracks
	parentTk.subTracks.push(subtk)

	subtk.querykey = parentTk.querykey
	subtk.mds = parentTk.mds

	subtk.parentTk = parentTk

	// subtk won't show legend, filtering criteria follows parent track
	delete subtk.infoFilter
	delete subtk.cohortFilter

	block.tk_load(subtk)

	parentTk.cohortFilter.hierarchies.keys[hierarchy.hierarchyname].allnodes
		.find(i => i.nodeid == hierarchy.nodeid)
		.showhidebutton.text('HIDE')
		.attr('class', 'sja_handle_red')
}

export function subtrackclosehandle(tk, block, y) {
	// make a Close handle for a subtrack

	return block
		.maketklefthandle(tk, y || 0)
		.text('Close')
		.on('click', () => {
			tk.parentTk.subTracks.splice(
				tk.parentTk.subTracks.findIndex(i => i.tkid == tk.tkid),
				1
			)
			block.tk_remove(block.tklst.findIndex(i => i.tkid == tk.tkid))
			tk.parentTk.cohortFilter.hierarchies.keys[tk.permanentHierarchy.hierarchyname].allnodes
				.find(i => i.nodeid == tk.permanentHierarchy.nodeid)
				.showhidebutton.text('SHOW')
				.attr('class', 'sja_handle_green')
		})
}
