/*
	Usage:
	tsx emitImports [> "test/internals.js"]

	- emit imports for dev server process (app) or running tests (unit)
	- the imports will trigger server restart when the target file is used with `tsx watch $targefile`
  - call from the working dir with a serverconfig.json

*/

import fs from 'fs'
import path from 'path'

const cwd = process.cwd()
const __dirname = import.meta.dirname

const namePattern = process.argv[2]
if (process.argv[2]) {
	console.log(getCodeText(process.argv[2]))
}

export function getCodeText(namePattern = '*.spec.*') {
	// prevent excessive imports
	if (!namePattern.includes('.spec.')) throw `namePattern does not include '.spec'`
	const exclude = ['dist/**', 'node_modules/**']
	let pattern = namePattern
	if (namePattern == '*.spec.*') {
		exclude.push('**/_x_.*')
		// use a more restrictive pattern in command-line or CI where process.argv[2] is always supplied,
		// in dev getCodeText() is called without an argument in client/esbuild.config.mjs and can be more loose
		if (arguments.length) pattern = '*@(unit|integration).spec.*'
	}
	const testPattern = `**/test/${pattern}`
	const specs = fs.globSync(testPattern, { cwd: __dirname, exclude }).map(file => ({ file, rel: `../${file}` }))
	const sharedUtils = path.join(__dirname, '../shared/utils')
	const sharedSpecs = fs
		.globSync(testPattern, { cwd: sharedUtils, exclude })
		.map(file => ({ file: `shared/utils/${file}`, rel: `../../shared/utils/${file}` }))
	specs.push(...sharedSpecs)
	specs.sort((a, b) => {
		if (a.file.includes('unit') && b.file.includes('unit')) return a < b ? -1 : 1
		if (a.file.includes('unit')) return -1
		if (b.file.includes('unit')) return 1
		return a.file < b.file ? -1 : 1
	})

	const output = [
		`// this file is auto-generated by client/emitImports.mjs, do not edit manually`,
		`import { matchSpecs, specsMatched } from './matchSpecs.js'`,
		`import tape from 'tape'`
	]

	// TODO: instead of using timeout and assertAllTested(), may be better to
	// just return await Promise.all() of all spec imports in a wrapper tape('')
	// callback, see code pattern in augen/src/test/relevant.js
	const initialTest = `
	// keep an initial test open until all spec modules have been loaded,
	// to prevent an early-loaded and very fast test from closing the
	// tape harness and ignoring late-loaded tests 
	let assertAllTestLoaded
	tape('loading of all import(spec)', test => {
		const exp = 5000
		test.timeoutAfter(exp)
		const start = Date.now()
		test.plan(1)
		console.log('NOTE: require() syntax in a client spec file may cause it to fail, use import syntax instead')
		assertAllTestLoaded = () => {
			if (Date.now() - start < exp) test.pass('should finish before this assertion is called')
			// else the timeoutAfter will be triggered without an assertion
			test.end()
		}
	})
	`
	// only keep an initial test open if there are matching specs to test
	if (specs.length) output.push(initialTest)

	output.push(`const promises = []`)
	// do not await on the dynamic import(), tape seems to collects all tests
	// within a given time so that they can all run in sequence, otherwise
	// if awaited, only the first spec file will run (tape seems to consider
	// all tests done at that point)
	specs.forEach(f => output.push(`if (matchSpecs('${f.file}')) promises.push(import('${f.rel}'))`))

	output.push(`// this resolves after all test modules are loaded, 
	// but likely before all test code are fully evaluated and completed 
	Promise.all(promises).then(()=>assertAllTestLoaded?.()).catch(e => {throw e})
	`)

	output.push(`export function getSpecs() { return specsMatched }`)

	const codeText = output.join('\n')
	return codeText
}

//if (outfile) fs.writeFileSync(path.join(__dirname, outfile), codeText)
//else console.log(codeText)
